name: Clean Up Recent Workflow Runs

# This workflow runs on a schedule (daily at 2 AM UTC) and can also be run manually.
on:
  schedule:
    - cron: '0 2 * * *'
  workflow_dispatch:

jobs:
  cleanup-recent-runs:
    runs-on: ubuntu-latest
    steps:
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install dependencies
        run: pip install requests

      - name: Run cleanup script for RECENT runs
        env:
          # This token is automatically provided by GitHub Actions.
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # The repository is automatically detected from the workflow's context.
          GITHUB_REPOSITORY: ${{ github.repository }}
          # --- Policy Configuration ---
          # Define how recent a run must be to be considered for deletion.
          DELETE_WITHIN_DAYS: 30
          # Define a safety net to always keep a certain number of the newest runs.
          KEEP_MINIMUM_RUNS: 1
        run: |
          python -c '
          import os
          import requests
          from datetime import datetime, timedelta, UTC

          # --- Configuration from Environment Variables ---
          token = os.getenv("GITHUB_TOKEN")
          repo = os.getenv("GITHUB_REPOSITORY")
          delete_within_days = int(os.getenv("DELETE_WITHIN_DAYS", "30"))
          keep_minimum = int(os.getenv("KEEP_MINIMUM_RUNS", "1"))

          if not token or not repo:
              print("Error: Required environment variables are not set.")
              exit(1)

          # --- Script Logic ---
          headers = {
              "Authorization": f"token {token}",
              "Accept": "application/vnd.github.v3+json"
          }

          # 1. Calculate the cutoff date. Runs created AFTER this will be targeted.
          cutoff_date = datetime.now(UTC) - timedelta(days=delete_within_days)

          print(f"Deletion Policy: Targeting runs created WITHIN the last {delete_within_days} days (after {cutoff_date.isoformat()}).")
          print(f"Safety Policy: Always keeping the {keep_minimum} most recent run(s).")

          # 2. Get the list of workflow runs from the GitHub API.
          runs_url = f"https://api.github.com/repos/{repo}/actions/runs"
          params = {"per_page": 100} # Fetch up to 100 runs.

          try:
              response = requests.get(runs_url, headers=headers, params=params)
              response.raise_for_status() # Raise an exception for bad status codes (4xx or 5xx)
          except requests.exceptions.RequestException as e:
              print(f"Error fetching workflow runs: {e}")
              exit(1)

          all_runs = response.json().get("workflow_runs", [])
          recent_runs_to_consider = []

          # 3. Filter for runs that are recent and not currently in progress.
          for run in all_runs:
              if run["status"] == "in_progress":
                  continue

              created_at = datetime.fromisoformat(run["created_at"])
              if created_at >= cutoff_date:
                  recent_runs_to_consider.append(run)

          if not recent_runs_to_consider:
              print("No recent runs found within the time window to delete.")
              exit(0)

          # 4. Sort runs from newest to oldest to apply the safety keep rule.
          recent_runs_to_consider.sort(key=lambda r: datetime.fromisoformat(r["created_at"]), reverse=True)

          # 5. Check if there are more runs than the minimum to keep.
          if len(recent_runs_to_consider) <= keep_minimum:
              print(f"Found {len(recent_runs_to_consider)} recent run(s), which is not more than the minimum of {keep_minimum} to keep. Nothing to delete.")
              exit(0)

          # The list of runs to delete is everything except the newest N runs.
          runs_to_delete = recent_runs_to_consider[keep_minimum:]

          print(f"Found {len(runs_to_delete)} recent run(s) to delete.")

          # 6. Loop through the final list and delete each run.
          for run in runs_to_delete:

              delete_url = f"https://api.github.com/repos/{repo}/actions/runs/{run['id']}"

              try:
                  del_response = requests.delete(delete_url, headers=headers)
                  del_response.raise_for_status()
                  print(f"Successfully deleted run ID: {run['id']} (Created: {run['created_at']})")
              except requests.exceptions.RequestException as e:
                  print(f"Failed to delete run ID {run['id']}: {e}")

          print("Cleanup complete.")
          '
