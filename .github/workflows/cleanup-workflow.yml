name: Cleanup Old Workflow Runs

on:
  workflow_dispatch:  # Allow manual trigger
  schedule:
    - cron: "0 0 * * 0"  # Weekly cleanup (Sunday midnight UTC)

jobs:
  cleanup:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'

      - name: Run Cleanup Script
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          DELETE_WITHIN_DAYS: 30
          KEEP_MINIMUM_RUNS: 1
        run: |
          python <<'EOF'
          #!/usr/bin/env python3
          """
          Author: Diwas Neupane
          Purpose: Delete recent GitHub Actions workflow runs while keeping a minimum number safe.
          Supports pagination beyond 100 runs.
          """

          import os
          import requests
          from datetime import datetime, timedelta, timezone

          # --- Configuration ---
          token = os.getenv("GITHUB_TOKEN")
          repo = os.getenv("GITHUB_REPOSITORY")
          delete_within_days = int(os.getenv("DELETE_WITHIN_DAYS", "30"))
          keep_minimum = int(os.getenv("KEEP_MINIMUM_RUNS", "1"))

          if not token or not repo:
              print("❌ Error: Required environment variables are not set.")
              exit(1)

          headers = {
              "Authorization": f"token {token}",
              "Accept": "application/vnd.github.v3+json"
          }

          cutoff_date = datetime.now(timezone.utc) - timedelta(days=delete_within_days)
          print(f"🧹 Deletion Policy: Runs created WITHIN last {delete_within_days} days (after {cutoff_date.isoformat()}).")
          print(f"🛡️ Safety Policy: Keeping the {keep_minimum} most recent run(s).")

          # --- Fetch all runs with pagination ---
          all_runs = []
          page = 1
          while True:
              runs_url = f"https://api.github.com/repos/{repo}/actions/runs"
              params = {"per_page": 100, "page": page}
              try:
                  response = requests.get(runs_url, headers=headers, params=params)
                  response.raise_for_status()
              except requests.exceptions.RequestException as e:
                  print(f"❌ Error fetching workflow runs (page {page}): {e}")
                  break

              runs = response.json().get("workflow_runs", [])
              if not runs:
                  break

              all_runs.extend(runs)
              page += 1

          print(f"📦 Total runs fetched: {len(all_runs)}")

          # --- Filter runs ---
          recent_runs = []
          for run in all_runs:
              if run.get("status") == "in_progress":
                  continue

              try:
                  created_at = datetime.strptime(run["created_at"], "%Y-%m-%dT%H:%M:%SZ").replace(tzinfo=timezone.utc)
              except (KeyError, ValueError):
                  print(f"⚠️ Skipping run with invalid 'created_at': {run}")
                  continue

              if created_at >= cutoff_date:
                  recent_runs.append(run)

          if not recent_runs:
              print("✅ No recent runs found within the time window to delete.")
              exit(0)

          recent_runs.sort(
              key=lambda r: datetime.strptime(r["created_at"], "%Y-%m-%dT%H:%M:%SZ"),
              reverse=True
          )

          if len(recent_runs) <= keep_minimum:
              print(f"ℹ️ Found {len(recent_runs)} run(s), not more than the minimum ({keep_minimum}). Nothing to delete.")
              exit(0)

          # --- Delete runs ---
          runs_to_delete = recent_runs[keep_minimum:]
          print(f"🗑️ Found {len(runs_to_delete)} run(s) to delete.")

          for run in runs_to_delete:
              run_id = run.get("id")
              if not run_id:
                  print(f"⚠️ Skipping run without ID: {run}")
                  continue

              delete_url = f"https://api.github.com/repos/{repo}/actions/runs/{run_id}"

              try:
                  del_response = requests.delete(delete_url, headers=headers)
                  del_response.raise_for_status()
                  print(f"✅ Deleted run ID: {run_id} (Created: {run['created_at']})")
              except requests.exceptions.RequestException as e:
                  print(f"❌ Failed to delete run ID {run_id}: {e}")

          print("🎉 Cleanup complete.")
          EOF
